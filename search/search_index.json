{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>Some parts of this page were written using ChatGPT.</p>"},{"location":"bachelors/","title":"Bachelors in Computer Science","text":""},{"location":"bachelors/ads/","title":"Algorithms and Datastructures","text":""},{"location":"bachelors/la/","title":"Linear Algebra","text":""},{"location":"bachelors/tcs/","title":"Theoretical Computer Science","text":""},{"location":"data/rtai/","title":"Reliable and Trustworthy Artificial Intelligence","text":""},{"location":"general/placeholder/","title":"Placeholder","text":""},{"location":"security/","title":"Secure and reliable systems","text":"<p>The content of this section is treating courses that are attributed to the major secure and reliable systems.</p>"},{"location":"security/zkp/","title":"Zero-Knowledge Proof","text":"<p>Zero-knowledge proofs are a cryptographic concept and a set of protocols that allow one party, called the prover, to demonstrate to another party, called the verifier, that they possess certain knowledge or information without revealing what that knowledge or information is. In other words, zero-knowledge proofs enable a party to prove that they know a secret or have access to specific data without disclosing the actual content of that secret.</p> <p>The primary goals of zero-knowledge proofs are privacy, security, and trust. They are particularly valuable in situations where one party needs to authenticate themselves or prove their knowledge of something to another party without revealing any sensitive details. Zero-knowledge proofs are used in various applications, including cryptography, cyber-security, and privacy-preserving technologies.</p>"},{"location":"security/zkp/intro-definitions/","title":"Introduction and definitions","text":""},{"location":"security/zkp/intro-definitions/#proofs","title":"Proofs","text":"<p>In general, a proof is used to establish trust between two parties, where a statement is established to be valid. Such a statement is established between two parties:</p> <ul> <li>Prover P (proof writer): Wants to prove a statement</li> <li>Verifier V (proof checker): verifies that the proof is valid</li> </ul> <p>Those parties are interacting with each other in different ways. See the following proof types:</p> <ul> <li>Mathematical proof: One-directional proof, where the prover makes a sequence of logical assertions. All errors   made are detectable by the verifier.</li> <li>Interactive proof (IP): Bi-directional proof, where the messages are randomised and adaptive. Most errors are   detectable by V. Increase proving power (more complex problems can be proven), and increased efficiency.</li> </ul> <p>Now, a general (dirty) description of Zero-Knowledge Proofs could be: Mathematical proofs that were extended with interactions, randomness, and cryptographic assumptions.</p>"},{"location":"security/zkp/intro-definitions/#complexity-classes","title":"Complexity classes","text":"<p>Problems can be separated in different complexity classes. Each class determines how problems can be solved. This mostly concerns the runtime of solving the problem. A Complexity class is a set of languages (problem types with similar properties, e.g. time complexity). A language \\(L\\) is a collection of problems \\(L \\subseteq \\{0,1\\}^*\\), where each problem statement \\(x\\) is a binary encoding of YES/NO \\(x \\in \\{0,1\\}^*\\).</p> <ul> <li>P: Problems are solvable in polynomial time (efficient) and are thus easy to solve. There exists an algorithm \\(M\\)   that is able to say if \\(x \\in L\\) or \\(x \\notin L\\). This is obvious and needs no proof.</li> <li>NP: Problems where it is easy to say that \\(x \\in L\\) using a witness w: \\((x,w) \\in R_L\\) However, there are no   checks in polynomial time that can prove that \\(x \\notin L\\). \\(x \\in L\\) has proof which is easy to check. However, the   witness might be hard to find.</li> <li>IP (interactive proof): Problems are proven using a prover and a verifier. They exchange a certain amount of   messages and the verifier concludes if the proof is valid or not. The verifier must be running polynomial time.   The algorithms are able to verify the two following properties:<ul> <li>Completeness (usually accepts true statements): \\(\\forall x \\in L, Pr_{r,s}[\\langle P(r),V(s)\\rangle (x) = 1]   \\geq \\frac{3}{4}\\)</li> <li>Soundness (usually rejects false statements): \\(\\forall x \\notin L, \\forall P^*, Pr_   {r,s}[\\langle P^*(r),V(s)\\rangle (x) = 1] \\leq \\frac{1}{2}\\)</li> </ul> </li> </ul> <p>In above formulas, \\(Pr_{r,s}\\) denotes a proof system that uses the random values \\(r\\) and \\(s\\), and \\(P^*\\) is any malicious prover. The probability to accept/reject the statements can be changed, as long as acceptance is greater than rejection probability.</p> <p>Increased proving power (seen in the previous chapter) allows for proofs of larger complexity classes.</p>"},{"location":"security/zkp/intro-definitions/#interactive-algorithms-and-interactive-proof","title":"Interactive Algorithms and Interactive Proof","text":"<p>Interactive algorithms are used to perform interactive proofs. A series of \\(k\\) messages are exchanged between the prover and verifiers. Each message \\(a_i\\) contains all \\(i-1\\) previous messages, as well as the input \\(x \\in \\{0,1\\}^*\\) and a random value \\(r\\) or \\(s\\). The complete interaction is denoted as \\(\\langle P^*(r),V(s)\\rangle (x) = a_{k(x)}\\). All  messages are stored in the transcript \\((x,a_1,...,a_{k(x)})\\) with \\(a_{k(x)}\\) being the verifiers conclusion if he  accepts or rejects the proof. </p> \\[ \\begin{align} a_1 &amp;= P(x,r) \\\\ a_2 &amp;= V(x,a_1,r) \\\\ a_3 &amp;= P(x,a_1,a_2,r) \\\\ \\vdots \\\\ a_{k(x)} &amp;= V(x,a_1,...,a_{k(x)-1},s) \\end{align} \\]"},{"location":"security/zkp/intro-definitions/#graph-isomorphism","title":"Graph Isomorphism","text":"<p>A problem that was seen in the course as an example is the graph-isomorphism problem. To our knowledge, no algorithm  exists that can proof if a graph is isomorphic. Isomorphic graphs are graphs that be mapped between each other using  some permutation \\(\\pi\\). </p>"},{"location":"security/zkp/intro-definitions/#zero-knowledge","title":"Zero-knowledge","text":""},{"location":"security/zkp/intro-definitions/#perfect-zero-knowledge","title":"Perfect Zero-knowledge","text":"<p>Perfect zero-knowledge is a special case of zero-knowledge proofs, and only a few of those exist. The proof must make  sure that the verifier gained no new knowledge - essentially, the verifier should be able to reproduce the proof by  themselves. \\((P,V)\\) is a perfect zero-knowledge proof, in case an efficient simulator \\(S\\) exists that is able to reproduce the verifier's view \\((x,s,a_1,...,a_{k(x)})\\).</p>"},{"location":"security/zkp/non-interactive-zk/","title":"Non-interactive zero-knowledge","text":""},{"location":"security/zkp/sigma/","title":"Sigma protocols","text":""},{"location":"security/zkp/zk-arguments-and-proofs/","title":"Zero-knowledge arguments with short proofs","text":""}]}