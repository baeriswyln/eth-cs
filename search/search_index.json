{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>Some parts of this page were written using ChatGPT.</p>"},{"location":"bachelors/","title":"Bachelors in Computer Science","text":""},{"location":"bachelors/ads/","title":"Algorithms and Datastructures","text":""},{"location":"bachelors/la/","title":"Linear Algebra","text":""},{"location":"bachelors/tcs/","title":"Theoretical Computer Science","text":""},{"location":"bachelors/tcs/languages/","title":"Languages","text":"<p>Before starting to learn about alphabets, words and languages, we require a couple of definitions.</p> <ul> <li>Alphabet \\(\\Sigma\\): Non-empty set containing symbols, letters, numbers, etc.<ul> <li>\\(| \\Sigma |\\): Cardinality, number of elements in alphabet</li> <li>\\(\\mathcal{P}(\\Sigma)\\): Every possible combination of the elements. Note that the empty set must be counted as well</li> </ul> </li> <li>Word \\(w\\): finite string of symbols from \\(\\Sigma\\)<ul> <li>\\(\\lambda\\): empty word, has length 0</li> <li>\\(|w|\\): length of word \\(w\\)</li> <li>\\(|w|_a\\): number of symbol \\(a\\) in word \\(w\\)</li> <li>\\(\\Sigma^*\\): set of all words that can be created using the alphabet \\(\\Sigma\\)</li> </ul> </li> <li>Subword \\(v\\): part of a word. \\(\\exists x,y \\in \\Sigma^* : w = xvy\\) where \\(x\\) is a prefix and \\(y\\) a suffix to \\(v\\)</li> <li>Language \\(L\\): set of words from \\(\\Sigma^*\\) with \\(L \\subseteq \\Sigma^*\\)<ul> <li>\\(L^c\\): complement, all words but the ones from \\(L\\). \\(L^c=\\Sigma^* - L\\)</li> <li>\\(L_\\emptyset\\): the empty language</li> <li>\\(L_\\lambda\\): the language only containing the empty word</li> <li>\\(L_1 \\cdot L_2\\): multiplication of two languages. Multiplying two words means concatenating them. Here, every word   from \\(L_1\\) is combined with those from \\(L_2\\). Example: \\(\\{a,ab\\}\\cdot\\{\\lambda,bc\\}=\\{a,abc,ab,abbc\\}\\)</li> <li>\\(|L|\\): cardinality, number of words in \\(L\\). Note that \\(|L_1\\cdot L_2| \\leq k \\cdot m\\) with \\(k=|L_1|,m=|L_2|\\)</li> <li>\\(L^n\\): exponentiation, multiplication of \\(L\\) with itself \\(n\\)-times. \\(L^{n+1}=L^n\\cdot L\\). Two additional special   cases: \\(L^* = \\bigcup_{i\\in\\mathbb{N}}L^i\\) and \\(L^+ = \\bigcup_{i\\in\\mathbb{N}-\\{0\\}}L^i\\)</li> </ul> </li> </ul>"},{"location":"bachelors/tcs/languages/#language-properties","title":"Language properties","text":"<p>The following chapters discuss some properties and operations for languages and words.</p>"},{"location":"bachelors/tcs/languages/#concatenation","title":"Concatenation","text":"<p>Words can be concatenated. \\(\\Sigma^* \\cdot \\Sigma^* = \\Sigma^*\\). A concrete example is \\(abb\\cdot bbc = abbbbc\\). This operation is associative (\\((a\\cdot b) \\cdot c = a \\cdot (b \\cdot c)\\) )  but not commutative (\\(a \\cdot b \\neq b \\cdot a\\)).</p> <p>\\(a^R\\) is the word \\(a\\) but its letters are in reverse order; \\(a=a_1a_2a_3, a^R=a_3a_2a_1\\).</p>"},{"location":"bachelors/tcs/languages/#cardinal-order","title":"Cardinal order","text":"<p>To get the cardinal order of a language, its words are first sorted by length. Words of the same length are then sorted lexicographically. In mathematical terms, the word \\(u\\) is in front of \\(v\\) if:</p> \\[ |u| &lt; |v| \\lor (|u|=|v| \\land u=xs_iu'\\land v=xs_jv'\\land s_i&lt;s_j) \\] <p>The last two equalities and the last inequality look for the first letter that is different.</p>"},{"location":"bachelors/tcs/languages/#arithmetics-with-languages","title":"Arithmetics with languages","text":"<p>Set operations can be applied on languages such as the subtraction, union, intersection, etc. The same rules apply as to sets, eg.</p> \\[ L_1L_2\\cup L_1L_3 = L_1(L_2\\cdot L_3) \\] <p>An additional definition defines the homomorphism between two languages \\(\\Sigma_1^*,\\Sigma_2^*\\) as every function \\(h: \\Sigma_1^* \\to \\Sigma_2^*\\) with the following properties: </p> <ol> <li>\\(h(\\lambda)=\\lambda\\)</li> <li>\\(h(uv) = h(u) \\cdot h(v)\\) for all \\(u,v\\in \\Sigma_2^*\\).</li> </ol>"},{"location":"bachelors/tcs/languages/#kolmogorov-complexity","title":"Kolmogorov-Complexity","text":""},{"location":"bachelors/tcs/languages/#random-objects","title":"Random objects","text":""},{"location":"bachelors/tcs/languages/#primefactor","title":"Primefactor","text":""},{"location":"data/rtai/","title":"Reliable and Trustworthy Artificial Intelligence","text":""},{"location":"data/rtai/robustness/","title":"Robustness","text":"<p>AIs have typically issues where they make false classifications due modified inputs. Such modifications can happen on data directly, or on the data that is being captured. All in all, it gets more and more important to have AIs that have a certain level of certified robustness giving some securities to the user. This is especially important for security-relevant applications.</p> <p>However, it is generally hard to certify models. And often, certification and improved robustness come with a certain cost regarding the model's performance, especially if those certifications are required to be scalable.</p>"},{"location":"data/rtai/robustness/#attacks","title":"Attacks","text":"<p>AI models have generally weaknesses and can be fooled by attackers. Adding a small amount of noise to an image can for example lead an image recognition model to wrong conclusions, or adding tape at certain spots on a stop sign can lead models to recognise it as a different sign.</p>"},{"location":"data/rtai/robustness/#adversarial-attacks","title":"Adversarial attacks","text":"<p>In adversarial attacks, we generally view two types of attacks:</p> <ul> <li>Targeted Attack where the attacker aims to classify the input as a specific label which differs from the   correct label.</li> <li>Untargeted Attack where the aim is to classify the input as some label that is not the correct one.</li> </ul> <p>The attacks can be further split into white box attacks where the attacker knows the complete model including parameters and the architecture, and black box attacks where the attacker only knows the architectures but has no information about the parameters.</p> <p>The following chapters only discuss white box attacks.</p>"},{"location":"data/rtai/robustness/#fast-gradient-sign-method-fgsm","title":"Fast Gradient Sign Method (FGSM)","text":"<p>This attack uses the gradient descent of the classification model. The loss function of the gradient descent is computed, and the added/removed from the input to form a modified output that should be classified with some other label. The loss function is, however, modified before being added/removed: only the sing of the values is looked at, not the exact value. This lead to better results than taking the gradient itself.</p> <p>First, the perturbation is computed. This is slightly different for the targeted (T) and untargeted (U) mode. In T, the loss function is computed for the target label 3, whereas in U, the original label s is used.</p> \\[ \\eta_{t/s} = \\epsilon \\cdot sign(\\nabla_xloss_{t/s}(x)) \\] <p>where \\(\\epsilon\\) a small value indicating how large the perturbation should be, and \\(sign(g)\\) returning -1 if \\(g &lt; 0\\), 0 if \\(g = 0\\), or 1 if \\(g &gt; 0\\). When applied to an image, \\(x_i\\) is a pixel of the image.</p> <p>As the output of the loss function is passed through the sign function, and then multiplied by \\(\\epsilon\\), the output is guaranteed to stay in the range \\(x \\pm \\epsilon\\). The original paper had a single iteration of this algorithm. If the perturbation did not change the output, the next input was looked at. The algorithm is designed to be fast and simple.</p> <ul> <li>Targeted: \\(x' = x-\\eta_t\\) modifies the input by minimising the loss for the label \\(t\\).</li> <li>Untargeted: \\(x' = x+\\eta_s\\) modifies the input by maximising the loss for the original label \\(s\\).</li> </ul>"},{"location":"data/rtai/robustness/#pgd","title":"PGD","text":""},{"location":"data/rtai/robustness/#adversarial-defenses","title":"Adversarial defenses","text":""},{"location":"data/rtai/robustness/#certification","title":"Certification","text":""},{"location":"data/rtai/robustness/#certified-defense","title":"Certified defense","text":""},{"location":"data/rtai/robustness/#relaxation","title":"Relaxation","text":""},{"location":"data/rtai/robustness/#box","title":"Box","text":""},{"location":"data/rtai/robustness/#milp","title":"MILP","text":""},{"location":"data/rtai/robustness/#deeppoly","title":"DeepPoly","text":""},{"location":"data/rtai/robustness/#diffpoly","title":"DiffPoly","text":""},{"location":"general/placeholder/","title":"Placeholder","text":""},{"location":"security/","title":"Secure and reliable systems","text":"<p>The content of this section is treating courses that are attributed to the major secure and reliable systems.</p>"},{"location":"security/zkp/","title":"Zero-Knowledge Proof","text":"<p>Zero-knowledge proofs are a cryptographic concept and a set of protocols that allow one party, called the prover, to demonstrate to another party, called the verifier, that they possess certain knowledge or information without revealing what that knowledge or information is. In other words, zero-knowledge proofs enable a party to prove that they know a secret or have access to specific data without disclosing the actual content of that secret.</p> <p>The primary goals of zero-knowledge proofs are privacy, security, and trust. They are particularly valuable in situations where one party needs to authenticate themselves or prove their knowledge of something to another party without revealing any sensitive details. Zero-knowledge proofs are used in various applications, including cryptography, cyber-security, and privacy-preserving technologies.</p>"},{"location":"security/zkp/intro-definitions/","title":"Introduction and definitions","text":""},{"location":"security/zkp/intro-definitions/#proofs","title":"Proofs","text":"<p>In general, a proof is used to establish trust between two parties, where a statement is established to be valid. Such a statement is established between two parties:</p> <ul> <li>Prover P (proof writer): Wants to prove a statement</li> <li>Verifier V (proof checker): verifies that the proof is valid</li> </ul> <p>Those parties are interacting with each other in different ways. See the following proof types:</p> <ul> <li>Mathematical proof: One-directional proof, where the prover makes a sequence of logical assertions. All errors   made are detectable by the verifier.</li> <li>Interactive proof (IP): Bi-directional proof, where the messages are randomised and adaptive. Most errors are   detectable by V. Increase proving power (more complex problems can be proven), and increased efficiency.</li> </ul> <p>Now, a general (dirty) description of Zero-Knowledge Proofs could be: Mathematical proofs that were extended with interactions, randomness, and cryptographic assumptions.</p>"},{"location":"security/zkp/intro-definitions/#complexity-classes","title":"Complexity classes","text":"<p>Problems can be separated in different complexity classes. Each class determines how problems can be solved. This mostly concerns the runtime of solving the problem. A Complexity class is a set of languages (problem types with similar properties, e.g. time complexity). A language \\(L\\) is a collection of problems \\(L \\subseteq \\{0,1\\}^*\\), where each problem statement \\(x\\) is a binary encoding of YES/NO \\(x \\in \\{0,1\\}^*\\).</p> <ul> <li>P: Problems are solvable in polynomial time (efficient) and are thus easy to solve. There exists an algorithm \\(M\\)   that is able to say if \\(x \\in L\\) or \\(x \\notin L\\). This is obvious and needs no proof.</li> <li>NP: Problems where it is easy to say that \\(x \\in L\\) using a witness w: \\((x,w) \\in R_L\\) However, there are no   checks in polynomial time that can prove that \\(x \\notin L\\). \\(x \\in L\\) has proof which is easy to check. However, the   witness might be hard to find.</li> <li>IP (interactive proof): Problems are proven using a prover and a verifier. They exchange a certain amount of   messages and the verifier concludes if the proof is valid or not. The verifier must be running polynomial time.   The algorithms are able to verify the two following properties:<ul> <li>Completeness (usually accepts true statements): \\(\\forall x \\in L, Pr_{r,s}[\\langle P(r),V(s)\\rangle (x) = 1]   \\geq \\frac{3}{4}\\)</li> <li>Soundness (usually rejects false statements): \\(\\forall x \\notin L, \\forall P^*, Pr_   {r,s}[\\langle P^*(r),V(s)\\rangle (x) = 1] \\leq \\frac{1}{2}\\)</li> </ul> </li> </ul> <p>In above formulas, \\(Pr_{r,s}\\) denotes a proof system that uses the random values \\(r\\) and \\(s\\), and \\(P^*\\) is any malicious prover. The probability to accept/reject the statements can be changed, as long as acceptance is greater than rejection probability.</p> <p>Increased proving power (seen in the previous chapter) allows for proofs of larger complexity classes.</p>"},{"location":"security/zkp/intro-definitions/#interactive-algorithms-and-interactive-proof","title":"Interactive Algorithms and Interactive Proof","text":"<p>Interactive algorithms are used to perform interactive proofs. A series of \\(k\\) messages are exchanged between the prover and verifiers. Each message \\(a_i\\) contains all \\(i-1\\) previous messages, as well as the input \\(x \\in \\{0,1\\}^*\\) and a random value \\(r\\) or \\(s\\). The complete interaction is denoted as \\(\\langle P^*(r),V(s)\\rangle (x) = a_{k(x)}\\). All messages are stored in the transcript \\((x,a_1,...,a_{k(x)})\\) with \\(a_{k(x)}\\) being the verifiers conclusion if he accepts or rejects the proof.</p> \\[ \\begin{align} a_1 &amp;= P(x,r) \\\\ a_2 &amp;= V(x,a_1,r) \\\\ a_3 &amp;= P(x,a_1,a_2,r) \\\\ \\vdots \\\\ a_{k(x)} &amp;= V(x,a_1,...,a_{k(x)-1},s) \\end{align} \\]"},{"location":"security/zkp/intro-definitions/#graph-isomorphism","title":"Graph Isomorphism","text":"<p>A problem that was seen in the course as an example is the graph-isomorphism problem. To our knowledge, no algorithm exists that can proof if a graph is isomorphic. Isomorphic graphs are graphs that be mapped between each other using some permutation \\(\\pi\\).</p>"},{"location":"security/zkp/intro-definitions/#zero-knowledge-zk","title":"Zero-knowledge (ZK)","text":"<p>The following chapters can be summarised with the following points:</p> <ul> <li>Perfect soundness and perfect zero knowledge cannot be achieved at the same time.</li> <li>Knowledge-soundness also good for \"trivial\" languages</li> <li>Special soundness and SHVZK are those that are used the most.</li> </ul> Soundness Zero Knowledge Proof size Proofs   (short term secrecy) Perfect/statistical Computational Not compressing Arguments (short window for cheating) Computational (short window for cheating) Perfect/statistical &lt;&lt;|x|, |w|"},{"location":"security/zkp/intro-definitions/#perfect-zero-knowledge","title":"Perfect Zero-knowledge","text":"<p>Perfect zero-knowledge is a special case of zero-knowledge proofs, and only a few of those exist. The proof must make sure that the verifier gained no new knowledge - essentially, the verifier should be able to reproduce the proof by themselves. \\((P,V)\\) is a perfect zero-knowledge proof, in case an efficient simulator \\(S\\) exists that is able to reproduce the verifier's view \\((x,s,a_1,...,a_{k(x)})\\).</p> <p>The following example describes a perfect ZKP for graph isomorphism. We have two graphs \\(G_0, G_1\\) that are isomorphic ( there exists a permutation mapping \\(G_0\\) to \\(G_1\\)).</p> <ol> <li>Prover takes a random permutation \\(\\sigma\\), and permutes \\(G_0\\) using this permutation which produces the graph    \\(H\\). \\(H\\) is sent to the verifier.</li> <li>Verifier sends randomly either 0 or 1 to the prover.</li> <li>Prover: if a 0 was received, prover sends \\(\\sigma\\) from step 1 to the verifier. If 1 was received,    \\(\\sigma \\circ \\pi\\) is sent to the verifier (with \\(G_0 = \\pi(G_1)\\)).</li> <li> <p>Verifier now applies the permutation sent by the prover either to \\(G_0\\) or \\(G_1\\) (depending on the random value    sent in step 2.). If the graphs are isomorphic, both ways should result in the random permutation \\(H\\).</p> </li> <li> <p>Completeness is good, as V will always accept if the graphs are isomorphic and the prover knows the permutation.</p> </li> <li>Soundness: say there graphs are not isomorphic, there exists no \\(H\\) that is both isomorphic to \\(G_0\\) and \\(G_1\\) at   the same time. This means that the generated \\(H\\) is only isomorphic to one of the graphs, and in the conversation, V   will only accept the provers response with a probability of 50%.</li> </ol> <p>This perfect zero-knowledge can now be proven using a simulator. Such a simulator is capable of reproducing the verifier's view, which in this case is \\(View_{V^*}^P = (G_0,G_1,\\tau,H,b)\\), with \\(V^*\\) a malicious verifier. The simulator \\(S(V^*,G_0,G_1)\\) then goes through the following steps:</p> <ol> <li>\\(\\tau\\) a random distribution</li> <li>\\(B\\) a random sample of 0 or 1</li> <li>\\(H = \\tau(G_B)\\)</li> <li>Sample \\(b\\) (just as malicious verifier would)</li> <li>If \\(b \\neq B\\), start from begining</li> <li>Output the expected verifiers view.</li> </ol>"},{"location":"security/zkp/intro-definitions/#variations-of-zero-knowledge","title":"Variations of Zero-knowledge","text":"<p>As mentioned before, perfect zero-knowledge is only possible for some languages. Thus, some relaxations are designed.</p> <ul> <li>Black-box zero-knowledge: the simulator only gets black-box access to the malicious verifier, which means that   he has no in-depth access to V, and is only capable of requesting a next symbol. It is noted as \\(S^{V^*}\\).</li> <li>Semi-honest verifier (SHVZK): uses an honest verifier that follows the protocol, but the secret is chosen very   carefully. For this reason, the simulator requires access to said secret.</li> <li>Honest verifier: the simulator has access to an honest verifier, which makes the simulator's job easier. Verifier   is following the protocol.</li> <li>Statistical ZK: the simulator can simulate the malicious verifier if he gets lucky.</li> <li>Computational ZK: the simulator can simulate the malicious verifier if he gets lucky or is hardworking.</li> <li>ZK with auxiliary inputs: additional input is given to prover and verifier (e.g. hint, witness, conversations of   prior protocol). The simulator requires additional input as well.</li> </ul>"},{"location":"security/zkp/intro-definitions/#variations-of-soundness","title":"Variations of Soundness","text":"<ul> <li>Knowledge soundness: \\(\\kappa\\) is the error of how sure one is that the prover is sound. An extractor \\(E\\) extracts   a witness from the prover (somewhat similar to black-box ZK, but the extractor has oracle access to the malicious   prover, producing a witness). The extractor can get both transformations \\(\\tau\\) from the prover (by inputting 0 and   1). The extractor can then extract \\(\\pi = \\tau_1 \\circ \\tau_0^{-1}\\)</li> <li>Interactive arguments: a proof should be convincing. But in this case, arguments can be held between the two   parties, because the protocol only holds against efficient provers. This means that cryptographic assumptions can   prove the soundness.</li> <li>Special soundness: connected to the public coin protocol. A knowledge extractor is used, taking the tree of   transcripts as an input to extract a witness. If such an extractor exists, the protocol with (2k+1) moves is   \\((n_1,...,n_k)-special sound\\). This soundness is typically easier to compute.</li> <li>Perfect, statistical and computational soundness also exist.</li> </ul>"},{"location":"security/zkp/intro-definitions/#public-coin-protocols","title":"Public coin protocols","text":"<p>In general, the verifier publicly sends random \"coin flips\" to the prover. Those are the only messages that are sent by the verifier, and are often also called challenges.</p> <p>The public coin flips can then be arranged in a tree of transcripts. The number of challenges defines the depth of the tree.</p>"},{"location":"security/zkp/non-interactive-zk/","title":"Non-interactive zero-knowledge","text":""},{"location":"security/zkp/sigma/","title":"Sigma protocols","text":"<p>The sigma protocols are the shortest and nicest possible interactive proofs. It is a 3-move public-coin protocol with the following properties:</p> <ul> <li>V always accepts if \\((x,w)\\in R\\)</li> <li>k-special sound, which means that an extractor exists that can extract the witness.</li> <li>SHVZK</li> </ul>"},{"location":"security/zkp/sigma/#commitment-schemes","title":"Commitment schemes","text":"<p>Sigma protocols require commitment schemes. A real world example of a commitment scheme are envelopes: a message is put into a (cryptographic) envelope, that can then no longer be opened by some other entity. The sender committed to a certain message and nobody is able to change this without the others noticing it.</p> <p>The commitment scheme is a collection of three algorithms:</p> <ul> <li>\\(Setup(1^\\delta)\\): public parameters pp are generated. Message space \\(\\mathfrak{M}\\), randomness space   \\(\\mathfrak{R}\\), decommitment space \\(\\mathfrak{D}\\) and commitment space \\(\\mathfrak{C}\\).</li> <li>\\(Commit(pp,m\\in\\mathfrak{M}, r \\gets_\\$ \\mathfrak{R})\\): creates a commitment and a decommitment \\((c,d)\\).</li> <li>\\(Verify(pp,c\\in\\mathfrak{C},d\\in\\mathfrak{D},m\\in\\mathfrak{M})\\): asks question if message was in commitment, and   consequently outputs 0 or 1.</li> </ul> <p>The commitments must be correct and secure. From this, the following points follow.</p> <ul> <li>Correctness: \\(\\forall pp, Verify(pp,Commit(pp,m,r),m)=1\\)</li> <li>Perfect hiding: the commitment should not disclose anything about the message.</li> <li>perfect binding: it must not be possible to change the message.</li> </ul> <p>Hiding and binding also exist as computational hiding and binding. It is not possible to have perfect binding ** and perfect hiding** at the same time.</p>"},{"location":"security/zkp/sigma/#elgamal-encryption","title":"Elgamal encryption","text":"<p>The elgamal is a computationally hiding and perfectly binding example of a commitment scheme. We sample a random prime number h (prime \\(p\\) of order \\(2^\\lambda\\) from \\(\\mathbb{G}\\)) and a secret key \\(s\\), which can then be used to compute \\(g = s \\cdot h\\). \\(\\mathbb{Z}_p\\) is the collection of integers from 0 to p-1, but the operations inside this set are done with mod p.</p> <ul> <li>Setup outputs \\(pp := (\\mathbb{G}, g, h, p)\\)</li> <li>\\(Commit(pp,m\\in\\mathbb{G},r\\gets_\\$\\mathbb{Z}_p)\\): \\(((c_1,c_2),d):=((m+r\\cdot g,r \\cdot h),r)\\)</li> <li>\\(Verify(pp,c,d,m)\\): \\((Commit(pp,m,d)==c)\\)</li> </ul>"},{"location":"security/zkp/sigma/#pedersen-commitment","title":"Pedersen commitment","text":"<p>The pedersen commitment can be plugged into sigma protocols to have a perfect hiding and computationally binding proof, and has the following steps. The protocol is perfectly hiding because \\(r\\cdot h\\) is uniformly random in \\(\\mathbb{G}\\).</p> <ul> <li>Setup generatesagain the same output.</li> <li>\\(Commit(pp,m\\in\\mathbb{Z}_p,r\\gets_\\$\\mathbb{Z}_p)\\): \\(((c_1,c_2),d):=((m\\cdot g,r \\cdot h),r)\\)</li> <li>\\(Verify(pp,c,d,m)\\): \\((Commit(pp,m,d)==c)\\)</li> </ul>"},{"location":"security/zkp/sigma/#example-three-coloring-graph","title":"Example - three-coloring graph","text":"<p>In a three-coloring graph, all adjacent nodes must be of different colours. The IP is as follows (\\(E\\) is the set of edges):</p> <ul> <li>Prover creates a permutation of the graph (the colors change, but the three-coloring stays valid) \\(\\sigma\\).   Additionally, the set of colors \\(col\\) is extracted. A commitment is created: \\((c_u,d_u) \\gets_\\$ Commit(pp,col_u)\\).</li> <li>Prover only sends the commitment \\(c_u\\) to the verifier (\\(u\\) is a vertex).</li> <li>Verifier picks a random edge \\((a,b)\\) from the graph and sends that to the prover</li> <li>Prover sends colors and decommitments of the requested edge to the verifier</li> <li>The verifier checks the commitment and decommitment.</li> </ul> <p>Completeness: the three-coloring stays valid after the permutation. Additionally, the commitment scheme makes sure that the verifier is always capable of correctly verifying the commitments/decommitments.</p> <p>\\(|E|\\)-special soundness: the tree of transcript must contain all edges, and no adjacent nodes must be the same color.</p> <p>There exists a simulator for SHVZK which reproduces the verifier's view that is the following (for a single edge in this example):\\(((c_u)_{u\\in V}(a,b),col_a,d_a,col_b,d_b)\\), and \\(Verify()==1\\) for both nodes a and b, and \\(col_a \\neq col_b\\). The simulator \\(S(pp,G,(a,b))\\) does the following steps (note that the simulator does not know the graph). Note that the simulator is kind of going backwards in the protocol.</p> <ol> <li>Sample two random colors \\(col_a, col_b\\) with \\(col_a \\neq col_b\\)</li> <li>\\((c_a,d_a) \\gets_\\$ Commit(pp,col_a)\\)</li> <li>\\((c_b,d_b) \\gets_\\$ Commit(pp,col_b)\\)</li> <li>All other nodes can be committed to some color (does not matter what, as they stay hidden)</li> <li>Results in the verifier's view</li> </ol>"},{"location":"security/zkp/sigma/#composition","title":"Composition","text":"<p>Often, protocols are repeated to improve the completeness/soundness errors. This might happen in sequence repetition or parallel repetition. The \\(\\Sigma\\)-protocols are often used with parallel repetition. The protocol stays largely unchanged, but instead of sending a single message, multiple messages are sent at once from the prover to the verifier.</p> <p>A 2-sound \\(\\Sigma\\)-protocol for example sends two messages in parallel, which will reduce the soundness error from \\(\\frac{1}{|C|}\\) to \\(\\frac{1}{|C|}\\).</p>"},{"location":"security/zkp/sigma/#and-composition","title":"AND composition","text":"<p>The sigma protocol is capable of combining two relations \\(R\\) and \\(R'\\) into a single relation \\(R_\\land\\). The messages exchanged are similar to the parallel repetition.</p> <p>For this composition to work, both \\(R\\) and \\(R'\\) require that the verifier's challenge space $\\mathfrak{C} is identical.</p> <ol> <li>P then sends first messages using both sigma protocols for \\(R\\) and \\(R'\\)</li> <li>V sends a single challenge \\(c\\). This is valid because the relations must share the challenge space</li> <li>P sends back a message according to the challenge</li> <li>V must then accept both individual verifiers</li> </ol> <p>The AND composition of two sigma protocol is pretty straight forward. The simulator for \\(R_\\land\\) is the combination for the individual relations: \\(S^\\land(x,x',c) := (S(x,c),S'(x',c))\\).</p> <p>The protocol is complete, k-special-sound and SHVZK.</p>"},{"location":"security/zkp/sigma/#or-composition","title":"OR composition","text":"<p>The preconditions for this composition is the same as for the AND composition. There is, however, a difference in how the prover and verifier work together. To start, the prover has only a witness for one of the relations. The prover for the second relation is simulated using a simulator.</p> <ol> <li>P generates message \\(a\\) using prover \\(P_1\\)</li> <li>P generates a random \\(c'\\) from the challenge space</li> <li>P simulates the message \\(a'\\) and \\(z'\\) using \\(c'\\)</li> <li>P sends both \\(a\\) and \\(a'\\) to the verifier</li> <li>V responds with a new random \\(c''\\)</li> <li>P computes \\(c := c''-c'\\), which is then used to compute \\(z\\)</li> <li>P sends \\(z,z'\\) and \\(c,c'\\) to the verifier</li> <li>V checks that both challenges were correctly answered, and \\(c+c' == c''\\)</li> </ol> <p>The protocol is complete, k-special-sound and SHVZK.</p>"},{"location":"security/zkp/sigma/#multi-party-computation","title":"Multi-Party computation","text":"<p>In this protocol \\(\\Pi\\), multiple players \\(P_i\\) want to arrive at a common conclusion (joint function) without leaking any of their private information \\(w_i\\), which also function as the private inputs. The players interact with each other over multiple rounds, and in the end all players should get the output. Additional inputs are a public input \\(x\\), and private randomness \\(r_i\\).</p> <p>The protocol is then specified by a next message function, specifying what message \\(m\\) a player \\(i\\) will send in round \\(j\\) to some other player \\(k, k\\neq i\\). The output is the message that is going to be sent by player \\(P_i\\) in round \\(j+1\\). \\(M\\) are all messages that were received by a certain player. </p> \\[ \\Pi \\big(i,x,w_i,r_i,(M_1,...,M_j)\\big) \\to (m_{j+1,i\\to k}) \\] <p>The protocol is correct, if all players get the correct output. If one input is not in the relation, all players  will get 0. </p> <p>The protocol has also t-privacy. This means that up to \\(t\\) players can be corrupted until the protocol looses its privacy. </p>"},{"location":"security/zkp/sigma/#view","title":"View","text":"<p>A player's view is defined as \\(View_i =(x,w_i,r_i,M_1,...,M_k)\\) where \\(M_j\\) is the set of all messages player \\(P_i\\) received from all other players in a specific round \\(j\\).</p> <p>Two views \\(View_i, View_j\\) are called consistent, if the messages in \\(View_i\\) sent by \\(View_j\\) actually match the  messages that can be computed using \\(View_j\\) and \\(\\Pi\\). This is called local consistency</p> <p>To get global consistency, all combinations of views must be pairwise consistent. If this is the case, there exists a  protocol with input \\(x\\) that matches all views.  </p>"},{"location":"security/zkp/sigma/#sigma-protocol-with-mpc-in-the-head","title":"Sigma-Protocol with MPC in the head","text":"<p>This protocol is called 'in the head' because the prover imagines the graph of players and computes all their witness and their views by themselfs. We now have \\(P(pp,x,w)\\) and \\(V(pp,x\\)) with \\(pp\\) the parameters from the setup function.</p> <ol> <li>P computes all witness for all players \\(w_i\\), with the additional condition that \\(w = w_1 \\oplus ... \\oplus w_n\\)</li> <li>P uses all \\(w_i\\), input \\(x\\) and \\(\\Pi\\) to compute the views</li> <li>P commits to the views, and sends all commitments to the verifier</li> <li>V chooses random players \\(i,j\\)</li> <li>P sends the views and decommitments of \\(i,j\\) to V</li> <li>V runs the verifying function Verfy\\((pp,c_i,d_i,View_i)=1\\), makes sure the views are consistent, and that     \\(P_i = P_j = 1\\)</li> </ol>"},{"location":"security/zkp/sigma/#fiat-shamir-heuristic","title":"Fiat-Shamir Heuristic","text":"<p>The protocol gives full zero knowledge and reduces the number of messages exchanged to 1. Additionally, a hash function \\(H\\) is required, that is modelled as a random oracle. The hash function maps onto the challenge space \\(C\\). Additionally,  \\(H\\) remembers the outputs (uniform random hash) that it has given for previous inputs. Giving the same input again will result in the identical output. </p> <p>Unlike the sigma protocol seen until now, P is generating \\(c = H(x,a)\\). He then sends \\(a\\), \\(c\\), and \\(z\\) to the  verifier. V does the same checks as usual, but also makes sure that \\(c\\) was generated correctly using the common hash function.</p> <p>Some notes: </p> <ul> <li>Hash more than less. If a commitment scheme is involved for example, the public parameters pp should be hashed as well</li> <li>Unsecure for real hash functions (only certain hash-functions can be used for a secure protocol)</li> <li>Signature scheme can be implemented, where the prover signs, and the verifier verifies. This method was used in the   picnic signature scheme that was a candidate as a post-quantum signature scheme. </li> </ul>"},{"location":"security/zkp/sigma/#sigma-protocol-against-malicious-verifiers","title":"Sigma protocol against malicious verifiers","text":"<p>If the verifier generates random challenges, there is no way to gain knowledge. However, non-uniformly-random challenges might leak information.</p> <p>To counter this, a public coin flip protocol is used. The verifier is forced to be honest by generating challenges  together with the prover.</p> <p>The prover generates his challenge \\(c\\) and commits to it. The commitment \\(C\\) is then sent to the verifier. V also  generates a secret \\(c'\\) that he sends back to the prover. P then answers with \\(c\\) and the decommitment \\(d\\), allowing  the verifier to check that \\(c\\) was not changed in the meantime. This procedure can then be interleaved with a message:</p> <ol> <li>P computes \\(a\\), \\(c\\), and \\(C\\), sending \\(a\\) and \\(C\\) to V</li> <li>V generates \\(c'\\) and sends it to P</li> <li>P computes \\(z \\gets_\\$ P_2(x,w,a,c'';p)\\) with \\(c'' := c + c'\\), then sends \\(z,c,d\\) to V</li> <li>V verifies that \\(c\\) has not been changed, and computes the output \\(V(x,a,c'',z)\\)</li> </ol>"},{"location":"security/zkp/zk-arguments-and-proofs/","title":"Zero-knowledge arguments with short proofs","text":""}]}